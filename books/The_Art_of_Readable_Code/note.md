# 读书笔记 -《编写可读代码的艺术》

## 前言

**观点**:

- 代码应该写得容易理解(使别人用最短的时间理解的代码）
- 软件开发的一个重要部分是要意识到你的代码以后将如何影响查看这些代码的人
- 细节决定成败，思路清晰、言简意赅的代码让程序一目了然；而格式凌乱、拖沓冗长的代码让程序一头雾水
- 优秀的代码必须具备良好的可读性，编写的代码要使其他人能在最短的时间内理解才行
- 对于一个整体的软件系统而言，既需要宏观的架构决策、设计与指导原则，也必须重视微观的代码细节
- 代码的优劣不仅直接决定了软件的质量，还将直接影响软件的成本
- 软件的成本由开发成本和维护成本组成，而往往维护成本要远高于开发成本
- 写出的代码能让人快速理解、轻松维护、容易扩展的程序员才是专业的程序员
- 当我们看到写得很漂亮的代码时，会很受启发。好代码会很明确告诉你它在做什么

**主要内容**:

- 简化命名、注释和格式的方法，使每行代码都言简意赅
- 梳理程序中的循环、逻辑和变量来减小复杂度并理清思路
- 在函数级别解决问题，例如重新组织代码块，使其一次只做一件事
- 编写有效的测试代码，使其全面而简洁、同时可读性更高

### 第一章：代码应当易于理解

- 写代码时可以使用的最重要的指导原则：代码应该易于理解
- **可读性基本定理**: 代码的写法应该使别人（即使只有一个人）理解它需要的时间最小化
- 减少代码行数是一个好目标，但少的代码并不总是更好；把理解代码所需要的时间最小化是一个更好的目标
- 可读性与其他目标并不冲突（效率、架构、容易测试等），总是有办法满足其它目标的同时让代码可读性更高
- 让代码容易理解往往会把它引向更好的架构且容易测试
- 当你犹豫不决时，可读性基本定理总是优于任何其他条例或原则

## 第一部分：表面层次的改进

- 表面层次的改进包括：选择好的名字、写好的注释以及把代码整洁地写成更好的格式
- 如果你的代码有很棒的名字、写得很好的注释，并且整洁地使用了空白符，你的代码会变得易读得多

### 第二章：把信息装到名字里

**选择专业的词**:

- 避免使用空洞的词:
  - `GetPage`中的`Get`含义不清（不能说明来源，cache、db、net），应使用`DownloadPage`或`FetchPage`
  - `BinaryTree.Size()`中的`Size`含义不清（高度、节点数、内存空间？），应使用`Height()`或`NumNodes()`或`MemoryBytes()`
  - `Thread.Stop()`中的`Stop`含义不清，应使用`Kill()`或`Pause()`
- 找到更具表现力的词, 清晰和精确比装可爱好
  - send: deliver, dispatch, announce, distribute, route
  - find: search, extract, locate, recover
  - start: launch, create, begin, open
  - make: crate, set up, build, generate, compose, add, new

**避免泛泛的名字**:

- 避免使用`tmp`、`retval`、`foo`这样的名字，使用一个能描述实体或目的的名字
- 有些情况下泛泛的名字也承载意义，如`tmp`作为一个临时变量
- `tmp`这个名字只应用于短期存在且临时性为其主要存在因素的变量
- i, j, iter, it 等名字常用做索引或循环迭代器，有时更精确的名字会更利于错误排查，如 user_i, ui, members_i, mi
- 对空泛名字的裁定：如果你要使用tmp、it等空泛的名字，那么你要有个好的理由

**用具体的名字替代抽象的名字**:

- 在给变量、函数或者其他元素命名时，要把它描述得更具体而不是更抽象
  - 例：一个方法用于检测是否可以监听某个端口，抽象的名称`ServerCanStart`，具体的名称`CanListenOnPort`
  - 例：谷歌代码中有一个名称`DISALLOW_EVIL_CONSTRUCTORS`，其中evil是抽象的，最终改成了`DISALLOW_COPY_AND_ASSIGN`
  - 例：`--run-locally`, 问题：1. 不知道到底做什么 2. 如果是输出调试信息，在远端程序也可能使用 3. 有时本地做信息测试可能不需要这个参数；应该使用像 `--extra_logging`, `--use-local-database`等具体含义的名称，哪怕要把一个`--run-locally`拆分为多个标识参数

**使用前缀或后缀来给名字附带更多信息**:

> 一个变量名就像是一个小小的注释，尽管空间不是很大，但不管你在名中挤进任何额外的信息，每次有人看到这个变量名时都会同时看到这些信息

- 如果一个变量格式很重要，可以将将其加入到变量名中，如：用`hex_id`代替`id`
- 表示度量的变量最好在名字上带上它的单位：start_md, elasped_ms, delay_secs, size_mb, max_kbps, degrees_cw
- 附加重要属性：如果这是一个需要理解的关键信息，就把它放在名字里
  - 变量存在危险或意外：untrustedUrl, unsafeMessageBody
  - 纯文本密码：planitext_password 代替 password
  - 转义后才能用于显示的注释：unescaped_comment
  - 已转化为utf8的html：html_utf8
  - 以url方式编码的输入数据：data_urlenc
- 标识变量的任何关键属性, 如果需要的话以易读的方式把它加到名字里

**决定名字的长度**:

- 选择好名字的隐含约束是名字不能太长；名字越长越难记，在屏幕上占用的地方越大，可能产生更多的换行
- 在小的作用域里可以使用短的名字；如果一个标识符有较大的作用域，那么它的名字就要包含足够的信息以便含义更清楚
- 不好输入不是避免使用长名字的理由，所有编程文本编辑器都有内置单词补全功能
- 是否使用首字母所略词或缩写的原则：团队新成员是否能理解这个名字的含义
  - 糟糕的例子：BEManager代替BackEndManager
  - 好的例子：eval 代替 evaluation，doc 代替 document， str 代替 string
- 丢掉没有的词，如：ToString 代替 ConvertToString， ServeLoop 代替 DoServeLoop

**利用名字的格式来表达含义**:

- 通过使用下划线、连字符和大小写可以把更多信息装到名字中
- 对不同实体使用不同个是能帮你更容易地阅读

### 第三章：不会误解的名字

- 要仔细审视名字会不会被别人解读成其他含义
  - 例：filter是个二义性的词，“挑出” 和 “减掉”
  - 例：`def Clip(text, length)`, 行为具有二义性（从尾部删除length的长度 或 保留长度为 length），length也具有歧义（字节数、字符数、字数）；调整为`def Truncate(text, max_chars)`
- 推荐用min/max来表示（包含）极限：max_, min_; limit 具有二义性（少于，少于且包括）
- 推荐用first/last来表示包含的范围；start/stop 中 stop具有二义性（少于，少于且包含）
- 推荐用begin/end来表示包含/排除范围；包含begin，不保护end
- 给布尔值命名
  - 通常is，has，can，should这样的词可以把布尔值变得更明确, 如：`bool read_password = true;`具有歧义（需要读密码，已经读密码），应该用 `need_password` 或 `user_is_authenticated`
  - 避免使用反义名词，如：使用 `bool use_ssl = true;` 代替 `bool disable_ssl = false;`
- 名字要与使用者的期望相匹配
  - 例: `get*()`, get通常被当作轻量级访问器，如果一个方法用于遍历所有经过的数据并计算中值，使用`getMean`容易让人误解这个调用的代价不大，此时应该使用`computeMean`代替
  - 例：C++标准库中有一个`list::size()`方法，是一个`O(n)`操作（遍历列表，计算个数），应该使用`countSize()`或`countElements()`；目前标准库已经把 size() 改成了 O(1)
- 如何权衡多个备选名字：选择对所发生的事情描述的最清楚，并且最不可能被误解的
  - 例：一个环境要从另一个环境继承一系列属性，指定另一个环境的变量名称备选项包括 template、reuse、copy、inherit，经过衡量 copy_experiement和inherit_from_experiment_id更好

### 第四章: 审美

- 好的源代码应该“看上去养眼”，原则如下：
  - 使用一致的布局，让读者很快就习惯这种风格
  - 让相似的代码看上去相似
  - 把相关的代码进行分组，形成代码块
- 观点：好的审美与好的设计是两种独立的思想，最好是同时在两个方向上努力做到最好
- 使用从审美角度讲让人愉悦的代码更容易；编程的大部分时间都是花在看代码上，浏览代码的速度越快，人们就越容易使用它
- 重新安排换行来保持一直和紧凑
- 如果多个代码块做相似的事情，尝试让他们有同样的剪影
- 使代码”看上去漂亮"通常会带来不限于表面层次的改进，它可能会帮你把代码的结构做得更好
- 在需要时使用列对齐，把代码按列对齐可以让代码更容易浏览
  - 是否应该使用列对齐的建议是尝试一下，如果真的很费工夫（建立和维护对齐的工作量）可以不使用
- 选一个有意义的顺序，始终一致地使用它（如果一段代码中提到A,B,C，那么不要在另一段中说B,C,A），例如：
  - 让变量的顺序与对应的HTML表单中input字段的顺序相匹配
  - 从”最重要“到”最不重要“
  - 按字母顺序排序
- 把声明按块组织起来：人类的大脑很自然地会按照分组和层次结构来思考，通过这样的组织方式可以帮助读者快速地理解你的代码
- 用空行把代码分成”段落“，建议给每个段落增加总结性的注释，原因如下：
  - 它是一种把相似的想法放在一起并与其他想法分开的方法
  - 它提供了可见的”脚印“，如果没有它，会很容易找不到你读到哪里了
  - 它便于段落之间的导航
- 一致的风格比”正确“的风格更重要

### 第五章：该写什么样的注释

**注释的目的是尽量帮助读者了解得和作者一样多**:
> 当你写代码时，你的脑海里会有很多有价值的信息。当其他人读你的代码时，这些信息已经丢失了 -- 他们所见到的只是眼前的代码

**什么不需要注释**:
> 阅读注释会占用阅读真实代码的时间，并且每条注释都会占用屏幕上的空间。那么，它们最好是物有所值的。

- 不要为那些从代码本身就能快速推断的事实写注释
- 不要为了注释而注释
- 不要给不好的名字加注释，应该把名字改好; 注释不应用于粉饰不好的名字，一个好的名字比一个好的注释更重要，因为在任何用到这个函数的地方都能看得到它
- 好代码 > 坏代码 + 好注释；通常，你不需要“拐杖式注释”（试图粉饰可读性差的代码的注释）

**什么需要注释**:
> 很多好的注释仅通过“记录你的想法"就能得到：那些你在写代码时有过的重要想法

- 加入指导性批注, 用注释来记录你对代码有价值的见解
  - 指导性批注：对于为什么代码写成这样而不是那样的内在理由
  - 例：`// 出乎意料的是，对于这些数据用二茶树比用哈希表快40%\n// 哈希运算的代价比左/右比较大得多`，这个注释教会读者一些事情，并且防止他们为无谓的优化而浪费时间
  - 例: `// 作为整体可能会丢掉几个词。这没有问题，要100%解决太难了` 如果没有这个注释，读者可能会以为这是个bug，然后浪费时间尝试找到能让它失败的测试用例，或者尝试改正这个bug
  - 例：`// 这个类正在变得越来越乱\n// 也许我们应该建立一个‘ResourceNode'子类来帮助处理` 这段注释承认代码很乱，同时也鼓励下一个人改正它，还给出了具体的建议
- 为代码中的瑕疵写注释
  - 代码始终在演进，并且在这个过程中肯定会有瑕疵，不要不好意思把这些瑕疵记录下来
  - 重要的是你应该可以随时把代码将来应该如何改动的想法用注释记录下来。这种注释给读者带来对代码质量和当前状态的宝贵见解。甚至可能会给他们指出如何改进代码的方向
  - 几种流行的标记：
    - `TODO`：我还没有处理的事情
    - `FIXME`：已知的无法运行的代码
    - `HACK`：对一个问题不得不采用的比较粗糙的解决方法
    - `XXX`：危险！这里有重要的问题
- 给常量写注释
  - 当定义常量时，通常在常量背后都有一个它是什么或者为什么是它的故事
  - 如果名字本身已经很清楚了，这些常量就不需要注释
- 站在读者的角度, 对于意料之中的提问，使用注释进行说明
- 公布可能的缺陷：
  - 例：某个函数会调用外部服务，调用时间可能会较长，应该用注释进行提示
  - 例：某个函数可能在深层嵌套时，相应会很慢，应予以提示
- "全局观"注释
  - 对于团队新成员来讲，最难的事情之一就是理解“全局观”
  - 在文件/类的级别上使用“全局观”注释来解释所有的部分是如何一起工作的
  - 如：类之间如何交互，数据如何在整个系统中流动，入口在哪里
- 总结性注释，做任何能帮助读者更容易理解代码的事（可能包含“做什么”、“怎么做”，“为什么”等），如：
  - 在一个函数内部给“全局观”写注释
  - 在包含几大块的长函数中为每块写总结性注释

**克服“作者心里阻滞”**:
> 很多程序员不喜欢写注释，因为要写出好的注释感觉好像要花很多工夫

- 方法：
  1. 不管你心里想什么，先把它写下来
  2. 读一下这段注释，看看有没有什么地方可以改进
  3. 不断改进
- 经常写注释，就会发现步骤1所产生的注释变得越来越好，最后可能不要做任何修改了
- 通过早些注释和常写注释，可以避免在最后要写一大堆注释这种令人不快的状况

### 第六章：写出言简意赅的注释

> 注释应该有很高的信息/空间率: 注释既要精确也要紧凑

- 让注释保持紧凑
- 避免使用不明确的代词: 当像“it”，“this”这样的代词可能代指多个事物时，避免使用他们
- 润色粗糙的句子
- 精确地描述函数的行为
- 用输入/输出例子来说明特别的情况: 一个精心挑选的输入/输出例子比千言万语还有效
- 声明代码的高层次意图，而非明显的细节
- 具名函数参数的注释: 如，按名字为参数赋值或为值添加注释来解释难以理解的函数参数
- 采用信息含量高的词使注释简洁
  - 有些普遍的问题和解决方案会重复出现，通常会有专门的名词或短语描述这种模式/定义，这些词会让你的注释更紧凑

## 第二部分：简化循环和逻辑

- **通过试着最小化“思维包袱”来达到目的**
- **思维包袱**: 一个复杂的逻辑、巨大的表达式或者一大堆变量 都会增加你头脑中的思维包袱

### 第七章：把控制流变得易读

- 把条件、循环以及其他对控制流的改变做得越“自然”越好，运用一种方式使读者不用停下来重复读你的代码
- 如果代码中没有条件判断、循环或者任何其他的控制流语句，那么它的可读性会很好。而跳转和分支等困难部分则会很快地让代码变得混乱
- 条件语句中参数的顺序：
  - 比较的左侧：“被问询的"表达式，它的值更倾向于不断变化
  - 比较的右侧：用来做比较的表达式，它的值更倾向于常量
  - 符合自然语言的习惯，如：”如果你小于18岁“ 和”如果18岁小于或等于你的年龄“，前者更自然
  - 尤达表达式**已经过时**，尤达表达式示例：`if (NULL == obj)`
- if/else 语句块的顺序：
  - 首先处理正逻辑而不是负逻辑的情况
  - 先处理掉简单的情况，这种方式可能还会使得if/else在屏幕之内都可见
  - 先处理有趣的或者可疑的情况
  - 如果负逻辑更简单并且更有趣或者更危险，那么先处理它
  - 有些时候倾向性之间会有冲突，根据具体情况的不同需要作者自己来判断
- *三目运算符（不被推荐）*:
  - 它对可读性的影响富有争议
  - 想对于追求最小化代码行数，一个更好的度量方法是最小化人们理解它所需要的时间
  - 默认情况下都用if/else。三目运算符只有在最简单的情况下使用
- *do/while语句（不被推荐）*:
  - 它的奇怪之处是一个代码块是否会执行是由其后的一个条件决定的
  - while 循环相对更易读；通常来讲，逻辑条件应该出现在他们所”保护“的代码之前
- 从函数中提前返回没有问题，而且常常很受欢迎
- *臭名昭著的GOTO，大多数情况下应该避免使用*
- 最小化嵌套
  - 嵌套很深的代码很难以理解；每个嵌套层次都在读者的”思维栈“上增加了一个条件；当读者见到右大扩号时，可能很难”出栈“来回忆起它背后的条件是什么
  - 当你对代码做改动时，从全新的角度审视它，把它作为一个整体来看待（不要简单的找到最容易插入的地方插入新代码）
  - 通过提早返回来减少嵌套
- 减少循环内的嵌套：提早返回不总是合适，循环中类似的技术是continue
- 编程语言和库提供的一些结构可能让你的代码更具可读性，并且冗余更少，但不要让你的代码中使用这些结构的比例太高
  - 线程：不清楚什么时间执行什么代码
  - 信号量/中断处理程序：有些代码可能随时执行
  - 异常：可能从多个函数调用中向上冒泡一样的执行
  - 函数指针和匿名函数：很难知道到底会执行什么代码，因为在编译时还没有决定
  - 虚方法：可能会调用一个未知子类的代码

### 第八章：拆分超长表达式

> - 研究表明，多数人只能同时考虑3～4件”事情“
> - 代码中的表达式越长，它就越难以理解
> - 把你的超长表达式拆分成更容易理解的小块

- 拆分表达式最简单的方法就是引入一个额外的变量（解释变量），让它来表示一个小一点的子表达式
- 解释变量：
  - 它把巨大的表达式拆成小段
  - 它通过用简单的名字描述子表达式来让代码文档化
  - 它帮助读者识别代码中的主要概念
- 总结变量：用一个短很多的名字来代替一大块代码；这个名字更容易管理和思考
- 使用德摩根定理：分别取反，转换与/或
  - `not (a or b or c) <=> (not a) and (not b) and (not c)`
  - `not (a and b and c) <=> (not a) or (not b) or (not c)`
- 要小心”智能“的小段代码--它们往往在以后会让别人读起来感到困惑
  - 难以理解的：`assert((!(bucket = FindBucket(key))) || !bucket->IsOccupied());`
  - 优化后的：
    - `bucket = FindBucket(key);`
    - `if (bucket != NULL) assert(!bucket -> IsOccupied());`
- 有时需要把问题”反向“或考虑目标的对立面来简化逻辑
- 在任何地方见到复杂的逻辑大胆地去拆分它们

### 第九章：变量与可读性
